# 95.How I built a wind map with WebGL.101
## <a name="index"></a> 目录
- [引子](#start)
- [正文](#main)
- [基于 CPU 的风场可视化](#wind)
- [OpenGL 基础](#opengl)
- [获取风场数据](#opengl)
- [GPU 上的移动粒子](#moving)
- [绘制粒子](#draw)
- [绘制粒子尾巴](#trails)
- [风场插值查找](#interpolating)
- [GPU 上的伪随机生成器](#generator)
- [下一步是什么？](#next)
- [参考资料](#reference)

## <a name="start"></a> 引子

## <a name="main"></a> 正文

![95-1][url-local-1]

查看我的[基于 WebGL 的风场模拟演示][url-2]！让我们深入了解它的工作原理。

我要坦白的说：在 [Mapbox][url-3] 工作的最后几年里，我像躲避瘟疫一样避免直接的 OpenGL/WebGL 编程。原因之一：OpenGL API 和术语让我深感恐惧。它看起来总是那么复杂、混乱、丑陋和冗长，以至于我永远都无法投入其中。只要听到 stencil masks、 mipmap、depth culling、 blend functions、 normal maps 等术语，我就会有一种不安的感觉。

今年，我最终决定直面我的恐惧，使用 WebGL 构建一些有意义的东西。2D 风场模拟看起来是一个完美的机会——它很有用，视觉上令人惊叹，而且具有挑战性，但在能力范围内感觉仍然可以实现。我惊讶地发现，它远没有看上去那么可怕！

## <a name="wind"></a> 基于 CPU 的风场可视化
网上有很多风力可视化的例子，但最受欢迎和最有影响的是 [Cameron Beccario][url-4] 的著名项目 [earth.nullschool.net][url-5] 。它本身不是开源的，但它有一个旧的[开源版本][url-6]，大多数其它实现都是基于这个版本编写代码的。一个著名的开源派生是 [Esri Wind JS][url-7] 。使用该技术的流行气象服务包括 [Windy][url-8] 和 [VentuSky][url-9] 。

![95-2][url-local-2]

通常，浏览器中的这种可视化依赖于 Canvas 2D API，大致如下所示：
1. 在屏幕上生成一组随机粒子位置并绘制粒子。
2. 对于每个粒子，查询风的数据以获取其当前位置的粒子速度，并相应地移动它。
3. 将一小部分粒子重置到随机位置。这样可以确保风吹走的区域永远不会完全变空。
4. 逐渐淡出当前屏幕，并在顶部绘制新定位的粒子。

这样做会有随之而来的性能限制：
- 风粒子的数量应保持较低（例如，地球示例使用~5k）。
- 每次更新数据或视图时都会有很大的延迟（例如，地球示例大约 2 秒），因为数据处理成本很高，而且发生在 CPU 端。

此外，要将其集成为基于 WebGL 的交互式地图（如 [Mapbox][url-10]）的一部分，你必须在每一帧上将画布元素的像素内容上传到 GPU ，这将大大降低性能。

我一直在寻找一种方法，用 WebGL 在 GPU 端重新实现完整的逻辑，这样它会很快，能够绘制数百万个粒子，并且可以集成到 Mapbox GL 地图中，而不会造成很大的性能损失。幸运的是，我偶然发现了 Chris Wellons 所写关于 [WebGL 中粒子物理][url-11] 的精彩教程，并意识到风场可视化可以使用相同的方法。

## <a name="opengl"></a> OpenGL 基础
令人困惑的 API 和术语使得 OpenGL 图形编程非常难以学习，但从表面上看，这个概念非常简单。这里有一个实用的定义：

> OpenGL 为高效绘制三角形提供了 2D API。

所以基本上你用 GL 所做的就是画三角形。除了可怕的 API 之外，困难还来自于执行此操作所需的各种数学和算法。它还可以绘制点和基本线（无平滑或圆形连接/封口），但很少使用。

![95-3][url-local-3]

OpenGL 提供了一种特殊的类 C 语言—— GLSL ——来编写由 GPU 直接执行的程序。每个程序分为两部分，称为着色器——顶点着色器和片段着色器。

**顶点着色器**提供用于转换坐标的代码。例如，将三角形坐标乘以 2 ，使我们的三角形看起来两倍大。我们在绘图时传递给 OpenGL 的每个坐标都将运行一次。一个基本的例子：

```c
attribute vec2 coord;
void main() {
    gl_Position = vec4(2.0 * coord, 0, 1);
}
```

**片段着色器**提供用于确定每个绘制像素颜色的代码。你可以用它做很多很酷的数学运算，但最终它类似“把三角形的当前像素画成绿色”。示例：

```c
void main() {
    gl_FragColor = vec4(0, 1, 0, 1);
}
```

在顶点着色器和片段着色器中，都可以做的一件很酷的事情是添加一个图像（称为纹理）作为参数，然后在该图像的任何点中查找像素颜色。我们将在风场可视化中很依赖这个。

片段着色器代码的执行是大规模并行的，并且硬件加速很快，因此通常比 CPU 上的等效计算快很多数量级。

## <a name="get"></a> 获取风场数据
## <a name="moving"></a> 基于 GPU 移动粒子
## <a name="draw"></a> 绘制粒子
## <a name="trails"></a> 绘制粒子尾巴
## <a name="interpolating"></a> 风场插值查找
## <a name="generator"></a> GPU 上的伪随机生成器
## <a name="next"></a> 下一步是什么？


<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="reference"></a> 参考资料
- [How I built a wind map with WebGL][url-1]

[url-1]:https://blog.mapbox.com/how-i-built-a-wind-map-with-webgl-b63022b5537f
[url-2]:https://mapbox.github.io/webgl-wind/demo/
[url-3]:https://www.mapbox.com/
[url-4]:https://twitter.com/cambecc
[url-5]:https://earth.nullschool.net/
[url-6]:https://github.com/cambecc/earth
[url-7]:https://github.com/Esri/wind-js/
[url-8]:https://www.windytv.com/
[url-9]:https://www.ventusky.com/
[url-10]:https://www.mapbox.com/maps/
[url-11]:http://nullprogram.com/blog/2014/06/29/

[url-local-1]:./images/95/1.png
[url-local-2]:./images/95/2.png
[url-local-3]:./images/95/3.png

<details>
<summary>:wastebasket:</summary>

![n-poster][url-local-poster]

</details>

[url-book]:https://book.douban.com/subject/26916012/
[url-local-poster]:./images/n/poster.jpg
