# 101.A GPU Approach to Particle Physics.107
## <a name="index"></a> 目录
- [引子](#start)
- [正文](#main)
- [粒子状态编码为颜色](#encoding)
- [title1](#entropy)
- [title1](#textures)
- [title1](#obstacles)
- [title1](#future)
- [参考资料](#reference)


## <a name="start"></a> 引子
想到[原文][url-2]中有提到参考的[教程][url-1]，就去看了下，发现对一些逻辑的理解很有帮助，顺便翻译记录一下。

- 原文：[A GPU Approach to Particle Physics][url-1]

## <a name="main"></a> 正文
我的 [GPGPU][url-3] 系列的下一个项目是一个粒子物理引擎，它在 GPU 上计算整个物理模拟。粒子受重力影响，会与场景几何体产生反弹。这个 WebGL 演示使用了着色器功能，并不需要严格按照 OpenGL ES 2.0 规范要求，因此它可能在某些平台上无法工作，尤其是在移动设备上。这将在本文后面讨论。

- [https://skeeto.github.io/webgl-particles/][url-4] ([source][url-5])

它是可交互的。鼠标光标是一个让粒子反弹的圆形障碍物，单击将在模拟中放置永久性障碍物。可以绘制和绘制粒子将流经的结构。你可以绘制粒子可以流过的结构。

这是示例的 HTML5 视频展示，出于必要，它以每秒 60 帧的高比特率录制，所以它相当大。视频编解码器不能很好地处理全屏所有粒子，较低的帧率也不能很好地捕捉效果。我还添加了一些在实际演示中听不到的声音。

<video src="https://nullprogram.s3.amazonaws.com/particles/particles.mp4"></video>

在现代 GPU 上，它可以以每秒 60 帧的速度模拟和绘制超过 4 百万个粒子。请记住，这是一个 JavaScript 应用程序，我没有真正花时间优化着色器，它受 WebGL 的约束，而不是像 OpenCL 或至少桌面 OpenGL 这样更适合一般计算的东西。

## <a name="encoding"></a> 粒子状态编码为颜色
就像 [Game of Life][url-6] 和 [path finding][url-7] 项目一样，模拟状态存储在成对的纹理中，大部分工作是在片元着色器中通过它们之间逐像素映射完成。我不会重复这个设置细节，所以如果你需要了解它是如何工作的，请参考 [Game of Life][url-6] 一文。

对于这个模拟，这些纹理中有四个而不是两个：一对位置纹理和一对速度纹理。为什么是成对的纹理？有 4 个通道，因此其中的每一个部分（x、y、dx、dy）都可以打包到自己的颜色通道中。这似乎是最简单的解决方案。

![101-1][url-local-1]

这个方案的问题是缺乏精确性。对于 R8G8B8A8 内部纹理格式，每个通道为一个字节。总共有 256 个可能的值。显示区域为 800×600 像素，因此不可能显示显示器上的每个位置。幸运的是，两个字节（总计 65536 个值）对于我们来说已经足够了。

![101-2][url-local-2]
![101-3][url-local-3]

下一个问题是如何跨这两个通道编码值。它需要覆盖负值（负速度），并应尽量充分利用动态范围，比如尝试使用所有 65536 个范围内的值。

要对一个值编码，将该值乘以一个标量，将其扩展到编码的动态范围。选择标量时，所需的最高值（显示的尺寸）是编码的最高值。

接下来，将动态范围的一半添加到缩放值。这会将所有负值转换为正值，0 表示最小值。这种表示法称为 [Excess-K][url-8] 。其缺点是用透明黑色清除纹理（glClearColor）不再将解码值设置为 0 。

最后，将每个通道视为基数为 256 的数字。OpenGL ES 2.0 着色器语言没有按位运算符，因此这是使用普通的除法和模来完成的。我用 JavaScript 和 GLSL 制作了一个编码器和解码器。JavaScript 需要它来写入初始值，并且出于调试目的，它可以读回粒子位置。

```c
vec2 encode(float value) {
    value = value * scale + OFFSET;
    float x = mod(value, BASE);
    float y = floor(value / BASE);
    return vec2(x, y) / BASE;
}

float decode(vec2 channels) {
    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;
}
```
JavaScript 与上面的标准化 GLSL 值（0.0-1.0）不同，这会生成一个字节的整数（0-255），用于打包到类型化数组中。
```js
function encode(value, scale) {
    var b = Particles.BASE;
    value = value * scale + b * b / 2;
    var pair = [
        Math.floor((value % b) / b * 255),
        Math.floor(Math.floor(value / b) / b * 255)
    ];
    return pair;
}

function decode(pair, scale) {
    var b = Particles.BASE;
    return (((pair[0] / 255) * b +
             (pair[1] / 255) * b * b) - b * b / 2) / scale;
}
```
更新每个粒子的片元着色器在该粒子的“索引”处对位置和速度纹理进行采样，解码它们的值，对它们进行操作，然后将它们编码回一种颜色，以便写入输出纹理。因为我使用的是 WebGL ，它缺少多个渲染目标（尽管支持 gl_FragData ），所以片元着色器只能输出一种颜色。位置在一个过程中更新，速度在另一个过程中更新为两个单独的绘图。缓冲区在两个过程完成后才会交换，因此速度着色器（有意）不会使用更新的位置值。

最大纹理大小有一个限制，通常为 8192 或 4096 ，因此纹理不是以一维纹理排列，而是保持方形。粒子由二维坐标索引。

看到直接绘制到屏幕上而不是正常显示的位置或速度纹理非常有趣。这是观看模拟的另一个领域，它甚至帮助我发现了一些其它方面很难看到的问题。输出是一组闪烁的颜色，但有明确的模式，展示了系统的许多状态（或不在其中的状态）。我想分享一段视频，但编码比普通显示更不切实际。以下是截图：位置，然后是速度。这里没有捕捉到阿尔法分量。

![101-4][url-local-4]
![101-5][url-local-5]

## <a name="entropy"></a> 熵保持
## <a name="textures"></a> Textures as Vertex Attribute Buffers
## <a name="obstacles"></a> Obstacles
## <a name="future"></a> Future Ideas


<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="reference"></a> 参考资料
- [A GPU Approach to Particle Physics][url-1]

[url-1]:https://nullprogram.com/blog/2014/06/29/
[url-2]:https://github.com/XXHolic/blog/issues/101
[url-3]:https://nullprogram.com/tags/gpgpu/
[url-4]:https://skeeto.github.io/webgl-particles/
[url-5]:https://github.com/skeeto/webgl-particles
[url-6]:https://nullprogram.com/blog/2014/06/10/
[url-7]:https://nullprogram.com/blog/2014/06/22/
[url-8]:http://en.wikipedia.org/wiki/Signed_number_representations#Excess-K

[url-local-1]:./images/101/1.png
[url-local-2]:./images/101/2.png
[url-local-3]:./images/101/3.png
[url-local-4]:./images/101/4.png
[url-local-5]:./images/101/5.png

<details>
<summary>:wastebasket:</summary>

![n-poster][url-local-poster]

</details>

[url-book]:https://book.douban.com/subject/26916012/
[url-local-poster]:./images/n/poster.jpg
